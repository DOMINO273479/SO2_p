#include <iostream>
#include <thread>
#include <vector>
#include <atomic>
#include <chrono>
#include <random>
#include <stdexcept>

using namespace std;

// Semaphore class for synchronization
class Semaphore {
private:
    atomic<int> count; // Atomic counter to ensure thread safety
public:
    Semaphore() : count(1) {}  // Default constructor
    Semaphore(int value) : count(value) {}
    
    void wait() {
        while (true) {
            int expected = count.load();
            if (expected > 0 && count.compare_exchange_weak(expected, expected - 1)) {
                break;
            }
        }
    }
    
    void signal() {
        count.fetch_add(1);
    }
};
    
// Dining Philosophers simulation class
class DiningPhilosophers {
private:
    int num_philosophers; // Number of philosophers
    vector<thread> philosophers; // Threads for philosophers
    vector<Semaphore> forks; // Semaphores representing forks
    Semaphore waiter; // Semaphore ensuring no deadlock
    atomic<bool> running; // Control flag for simulation
    vector<int> eating_count; // Tracks how many times each philosopher eats

    // Function representing a philosopher's actions
    void philosopher(int id) {
        try {
            random_device rd;
            mt19937 gen(rd());
            uniform_int_distribution<> dist(1000, 3000); // Random delay between 1-3 seconds
            
            while (running.load()) {
                log_status(id, "is thinking");
                this_thread::sleep_for(chrono::milliseconds(dist(gen))); // Thinking phase
                
                log_status(id, "is hungry");
                waiter.wait(); // Ensure only N-1 philosophers pick up forks
                
                forks[id].wait(); // Pick up left fork
                forks[(id + 1) % num_philosophers].wait(); // Pick up right fork
                
                log_status(id, "is eating");
                eating_count[id]++; // Track eating count
                this_thread::sleep_for(chrono::milliseconds(dist(gen))); // Eating phase
                
                forks[id].signal(); // Release left fork
                forks[(id + 1) % num_philosophers].signal(); // Release right fork
                
                waiter.signal(); // Allow another philosopher to eat
            }
        } catch (const exception &e) {
            cerr << "Exception in philosopher " << id << ": " << e.what() << endl;
        }
    }
    
    // Function to log the status of philosophers
    void log_status(int id, const string &status) {
        cout << "Philosopher " << id << " " << status << endl;
    }

public:
    // Constructor initializing semaphores and philosopher count
    DiningPhilosophers(int n) : num_philosophers(n), forks(n), waiter(n - 1), running(true), eating_count(n, 0) {}
    
    // Function to start the simulation
    void start() {
        for (int i = 0; i < num_philosophers; ++i) {
            philosophers.emplace_back(&DiningPhilosophers::philosopher, this, i);
        }
        
        this_thread::sleep_for(chrono::seconds(10)); // Run for 10 seconds
        running.store(false); // Stop simulation
        
        for (auto &philosopher : philosophers) {
            philosopher.join(); // Wait for all threads to finish
        }

        // Print final eating counts for fairness tracking
        cout << "\nEating count per philosopher:" << endl;
        for (int i = 0; i < num_philosophers; ++i) {
            cout << "Philosopher " << i << " ate " << eating_count[i] << " times." << endl;
        }
    }
};

// Main function to initialize the simulation
int main(int argc, char* argv[]) {
    if (argc != 2) {
        cerr << "Usage: " << argv[0] << " <number_of_philosophers>" << endl;
        return 1;
    }
    
    int num_philosophers;
    try {
        num_philosophers = stoi(argv[1]); // Get number of philosophers from arguments
        if (num_philosophers <= 1) {
            throw invalid_argument("Number of philosophers must be greater than 1.");
        }
    } catch (const exception &e) {
        cerr << "Invalid input: " << e.what() << endl;
        return 1;
    }
    
    DiningPhilosophers dp(num_philosophers); // Create simulation instance
    dp.start(); // Start simulation
    
    return 0;
}
